
HubApi.cpp
里面的 S_onMessage() 执行 各种get_xxx()

### FuBo BaBo FuList等结构

MdSpi.cpp 中定义了
```c
std::map<std::string,uBEE::FuBo>    M_FuBo;         // 每个期货一个 FuBlock，构成一个MAP

std::shared_ptr<uBEE::DBPool> dbpool;
uBEE::FuList                  *fl;
uBEE::TimeBlock               *tb;
```
...... 每个 future 生成一个 future block ( new uBEE::FuBo )

```
FuList 
=============:ag1804
=============:ag1805
=============:ag1806
=============:ag1807
=============:ag1808
=============:ag1809
=============:ag1810
=============:ag1811
=============:ag1812
=============:ag1901
=============:ag1902
=============:ag1903
=============:al1804
=============:al1805
=============:al1806
=============:al1807
=============:al1808
=============:al1809
=============:al1810
=============:al1811
=============:al1812
=============:al1901
=============:al1902
=============:al1903
...
...
...
```

### M_FuBo MAP < future, FuBo >
每个future 一个FuBo
```c
map :
........ ag1804:FuBo==>
        struct FuBo {
          std::shared_ptr<uBEE::DBPool> dbpool;
          char         InstrumentID[31];
          char         caFileName[1024];            // 用于记录"/home/rabbit/see/dat/rcv_dat/au/au1801",要组合 period
          int          iCurIdx ;                    // 用于记录收到tick时，是在哪个交易时间段内
          stTimeType  *pTimeType ;                  // TimeType 交易时间类型
          BaBo        *pBaBo[50] ;                 // 1s 2s 3s ... 1f 2f 3f 5f ... 1h 5h ... 1y tick
        public:
          FuBo(char *fuID, uBEE::TimeBlock *tmbo,const int period[],int len);
        };
        //--------------------------------------------------------------------------------------
            ........ pBaBo[0]   1S
            ........ pBaBo[1]   2S
            ........ pBaBo[2]   3S
            ........ pBaBo[3]   5S
            ........ pBaBo[4]   10S
            ........ pBaBo[5]   20S
            ........ pBaBo[6]   30S
            ........
            struct BaBo {
              stBar         bar0 ;
              stBar         bar1 ;
              stBar         *pbar0 ;
              stBar         *pbar1 ;
              stBar         *b0 ;
              stBar         *b1 ;
              char          curB[9];            //记录当前tick所在的段
              char          curE[9];
              int           curiB ;             //记录当前tick所在的段
              int           curiE ;
              int           iBidx;              // 此bar1的起始点所在的 segment idx，
              int           iEidx;              // 此bar1的结束点所在的 segment idx，
              int           iF;                 // 0:tick 1:2s, 60:1F ---- 周期 ： 以秒计
              int           iH;                 // 将周期转成 H M S, 比如：周期为 97 秒 转成： iPeriodH=0 ;
              int           iM;                 // iPeriodM = 1;
              int           iS;                 // iPeriodS = 37;  需要初始化！！
              char          cF[10] ;             // frequency ; "1S" "2S" ...
              char          c_save ;                    /* 's' 表示 save  'n' 表示 不需要save */
              int           i_bar_type ;                // 1 2 3 5 10 15   这个值可以用来计算 新来的tick是不是在同一个K
              char          c_bar_type ;                // S F H D W M J Y  BAR_SECOND BAR_MINUTE ...
              char          ca_table[128];                 /* database table name */
              int           iSegNum ;          // segment 数量
              stSegment     *seg[100] ;        // segment array
            public:
              BaBo(const char *pF, int fr, stTimeType  *pTimeType);
              int MakeTime(char *caTime, int T) ;
            } ;
            //------------------------------->
            ---------> seg[0] 
            ---------> seg[1]
            ---------> seg[2]
            ---------> seg[3] 
            ---------> seg[4]
            ---------> seg[5]
            //------------------------------->
                        struct stSegment {
                          char cB[9];
                          char cE[9];
                          int  iB ;
                          int  iE ;
                          int  iI ;  //和前一个 segment之间的间隔。如果是第一个segment， iI = 0;
                          int  mark ; // 0 表示 seg 包含 bar。 // 1.2.3. 表示 一个bar 包含多个 seg。
                          char barB[9];
                          char barE[9];
                        };
            
            
            bar0:
            bar1:
            //------------------------------->
                      struct stBar {
                        char    TradingDay[9];
                        char    ActionDay[9];
                        char    cB[9];        //begin time BAR K柱 的开始时间
                        char    cE[9];        //end time
                        int     iB ;          // 当前K柱 起始时间
                        int     iE ;          // 当前K柱 结束时间
                        int     iBidx;          // 此bar的起始点所在的 segment idx，
                        int     iEidx;          // 此bar的结束点所在的 segment idx，
                        double  h ;             // high
                        double  o ;             // open
                        double  c ;             // close
                        double  l ;             // low
                        int     v ;             // volume
                        int     vsum ;          // keep volume sum
                      };
            
//****************************************************************************************************************            
........ ag1805:FuBo==>

........ ag1806:FuBo==>

........ ag1807:FuBo==>

```
### 【K柱的计算过程】
```c
  // 经过重新设计， 不管K柱是不是跨时间段，只要tick落在 curB---curE之间，即UPDATE。
  //-----------------------------------------------------------
  if(memcmp(tick->UpdateTime,curB,8)>=0 &&
     memcmp(tick->UpdateTime,curE,8)<0) { // 在当前的 curB curE 这个segment内
    UPDATE_BAR1;
    return 0;
  }
  // ***********【1】 mark==0  一个seg包含一个或多个bar的情况

  //    【A】【B】【C】:  barE <= tick <= segE
  //  ------| ----------|...cur...|-----------------|------
  //    segB|        barB      barE             segE|
  //
  //    【D】 : barE == segE == tick
  //  ------| ----------------------------|...cur...|------
  //        |                         barB|     barE|
  //    segB|                                   segE|
  //
  //    【E】  tick 落在 segE 之外
  // }
  // {
  // ***********【2】 mark>0  一个bar包含多个seg的情况
  //  -------|........seg1|.......seg2|^^^^^^^^|.......seg3|----
  //     barB|                                         barE|----
  //   【A】【B】【C】 属于 barE > cur_segE的情况
  //   【D】 属于 barE = segE的情况
  //   【E】  tick 落在 segE 之外
  // }

  /*
  【1】******************* mark==0  一个seg包含一个或多个bar的情况
  【A】： barE ==tick < segE   { curBar结束，newBar}
  【B】： barE < tick < segE   { curBar结束，newBar也可能结束，再new一个bar}
  【D】： barE ==tick== segE   { curBar结束，在此seg之外，紧临，再new 一个bar }    和后面一样 bar结束， seg也结束
  【E】： tick > (segE barE)   { curBar结束，在此seg之外，while，再new 一个bar }   这种情况要处理 00:00:00 ----
  情形【E】要修改， 如果tick 是 00:00:00 其实也在 barE 之外，因为barE 是 24:00:00。但 tick < segE
   */
  /*
  【2】******************** mark>0  一个bar包含多个seg的情况
  【A】： segE ==tick < barE   { curseg结束，}  // (charmi  注意 24小时问题, 有可能 barE < segE !!!)
  【B】： segE < tick < barE   { curseg结束，}
  【C】： segE < tick== barE   { curbar结束，}
  【D】： segE ==tick== barE   { curbar结束，在此seg之外，紧临，再new 一个bar }
  【E】： tick > (barE segE)   { curbar结束，在此seg之外，while，再new 一个bar }
   情形【E】要修改， 如果tick 是 00:00:00 其实也在 barE 之外，因为barE 是 24:00:00。但 tick < barE
   以上【A】和【B】 合成一个 ： if( tick < barE) {  从next   seg   开始检查 tick是否在  其中  }
  【E】单独成一项。 检查  tick在哪个 seg中，然后计算 在哪个bar中。 和前面一种情况的【E】 处理方法一样。
   */

  //-----------------------------------------------------------
  /*
    curB--curE
    barB--barE
    segB--segE
    mark ==> 每个seg的类型, 0:表示这个seg包含多个bar。 1：2：3：表示 此seg属于某个bar。
    idx  ==> seg 数组下标
  */
```
